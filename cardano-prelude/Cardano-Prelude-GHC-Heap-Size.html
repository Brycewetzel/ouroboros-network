<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Cardano.Prelude.GHC.Heap.Size</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">cardano-prelude-0.1.0.0: A Prelude replacement for the Cardano project</span><ul class="links" id="page-menu"><li><a href="src/Cardano.Prelude.GHC.Heap.Size.html">Source</a></li><li><a href="&quot;../index.html&quot;">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Cardano.Prelude.GHC.Heap.Size</p></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><span class="keyword">data</span> <a href="#t:CountFailure">CountFailure</a><ul class="subs"><li>= <a href="#v:WorkListFull">WorkListFull</a></li><li>| <a href="#v:VisitedFull">VisitedFull</a></li><li>| <a href="#v:OutOfMemory">OutOfMemory</a></li><li>| <a href="#v:UnsupportedClosure">UnsupportedClosure</a> <a href="file:///opt/ghc/8.10.2/share/doc/ghc-8.10.2/html/libraries/ghc-heap-8.10.2/GHC-Exts-Heap-ClosureTypes.html#t:ClosureType" title="GHC.Exts.Heap.ClosureTypes">ClosureType</a></li></ul></li><li class="src short"><span class="keyword">data</span> <a href="#t:PerformGC">PerformGC</a><ul class="subs"><li>= <a href="#v:FirstPerformGC">FirstPerformGC</a></li><li>| <a href="#v:DontPerformGC">DontPerformGC</a></li></ul></li><li class="src short"><a href="#v:computeHeapSize">computeHeapSize</a> &#8759; a &#8594; <a href="Cardano-Prelude-Base.html#t:IO" title="Cardano.Prelude.Base">IO</a> (<a href="Cardano-Prelude-Base.html#t:Either" title="Cardano.Prelude.Base">Either</a> <a href="Cardano-Prelude-GHC-Heap-Size.html#t:CountFailure" title="Cardano.Prelude.GHC.Heap.Size">CountFailure</a> <a href="Cardano-Prelude-Base.html#t:Word64" title="Cardano.Prelude.Base">Word64</a>)</li><li class="src short"><a href="#v:computeHeapSize-39-">computeHeapSize'</a> &#8759; <a href="Cardano-Prelude-GHC-Heap-Size.html#t:PerformGC" title="Cardano.Prelude.GHC.Heap.Size">PerformGC</a> &#8594; <a href="Cardano-Prelude-Base.html#t:Word" title="Cardano.Prelude.Base">Word</a> &#8594; <a href="Cardano-Prelude-Base.html#t:Word" title="Cardano.Prelude.Base">Word</a> &#8594; <a href="Cardano-Prelude-Base.html#t:Word" title="Cardano.Prelude.Base">Word</a> &#8594; a &#8594; <a href="Cardano-Prelude-Base.html#t:IO" title="Cardano.Prelude.Base">IO</a> (<a href="Cardano-Prelude-Base.html#t:Either" title="Cardano.Prelude.Base">Either</a> <a href="Cardano-Prelude-GHC-Heap-Size.html#t:CountFailure" title="Cardano.Prelude.GHC.Heap.Size">CountFailure</a> <a href="Cardano-Prelude-Base.html#t:Word64" title="Cardano.Prelude.Base">Word64</a>)</li><li class="src short"><a href="#v:computeHeapSizeWorkList">computeHeapSizeWorkList</a> &#8759; a &#8594; <a href="Cardano-Prelude-Base.html#t:Word64" title="Cardano.Prelude.Base">Word64</a></li></ul></details></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:CountFailure" class="def">CountFailure</a> <a href="src/Cardano.Prelude.GHC.Heap.Size.html#CountFailure" class="link">Source</a> <a href="#t:CountFailure" class="selflink">#</a></p><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a id="v:WorkListFull" class="def">WorkListFull</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a id="v:VisitedFull" class="def">VisitedFull</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a id="v:OutOfMemory" class="def">OutOfMemory</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a id="v:UnsupportedClosure" class="def">UnsupportedClosure</a> <a href="file:///opt/ghc/8.10.2/share/doc/ghc-8.10.2/html/libraries/ghc-heap-8.10.2/GHC-Exts-Heap-ClosureTypes.html#t:ClosureType" title="GHC.Exts.Heap.ClosureTypes">ClosureType</a></td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><h4 class="instances details-toggle-control details-toggle" data-details-id="i:CountFailure">Instances</h4><details id="i:CountFailure" open="open"><summary class="hide-when-js-enabled">Instances details</summary><table><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:CountFailure:Eq:1"></span> <a href="Cardano-Prelude-Base.html#t:Eq" title="Cardano.Prelude.Base">Eq</a> <a href="Cardano-Prelude-GHC-Heap-Size.html#t:CountFailure" title="Cardano.Prelude.GHC.Heap.Size">CountFailure</a></span> <a href="src/Cardano.Prelude.GHC.Heap.Size.html#line-44" class="link">Source</a> <a href="#t:CountFailure" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:CountFailure:Eq:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Cardano-Prelude-GHC-Heap-Size.html">Cardano.Prelude.GHC.Heap.Size</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:-61--61-">(==)</a> &#8759; <a href="Cardano-Prelude-GHC-Heap-Size.html#t:CountFailure" title="Cardano.Prelude.GHC.Heap.Size">CountFailure</a> &#8594; <a href="Cardano-Prelude-GHC-Heap-Size.html#t:CountFailure" title="Cardano.Prelude.GHC.Heap.Size">CountFailure</a> &#8594; <a href="Cardano-Prelude-Base.html#t:Bool" title="Cardano.Prelude.Base">Bool</a> <a href="#v:-61--61-" class="selflink">#</a></p><p class="src"><a href="#v:-47--61-">(/=)</a> &#8759; <a href="Cardano-Prelude-GHC-Heap-Size.html#t:CountFailure" title="Cardano.Prelude.GHC.Heap.Size">CountFailure</a> &#8594; <a href="Cardano-Prelude-GHC-Heap-Size.html#t:CountFailure" title="Cardano.Prelude.GHC.Heap.Size">CountFailure</a> &#8594; <a href="Cardano-Prelude-Base.html#t:Bool" title="Cardano.Prelude.Base">Bool</a> <a href="#v:-47--61-" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:CountFailure:Show:2"></span> <a href="Cardano-Prelude-Base.html#t:Show" title="Cardano.Prelude.Base">Show</a> <a href="Cardano-Prelude-GHC-Heap-Size.html#t:CountFailure" title="Cardano.Prelude.GHC.Heap.Size">CountFailure</a></span> <a href="src/Cardano.Prelude.GHC.Heap.Size.html#line-44" class="link">Source</a> <a href="#t:CountFailure" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:CountFailure:Show:2"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Cardano-Prelude-GHC-Heap-Size.html">Cardano.Prelude.GHC.Heap.Size</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:showsPrec">showsPrec</a> &#8759; <a href="Cardano-Prelude-Base.html#t:Int" title="Cardano.Prelude.Base">Int</a> &#8594; <a href="Cardano-Prelude-GHC-Heap-Size.html#t:CountFailure" title="Cardano.Prelude.GHC.Heap.Size">CountFailure</a> &#8594; <a href="file:///opt/ghc/8.10.2/share/doc/ghc-8.10.2/html/libraries/base-4.14.1.0/Text-Show.html#t:ShowS" title="Text.Show">ShowS</a> <a href="#v:showsPrec" class="selflink">#</a></p><p class="src"><a href="#v:show">show</a> &#8759; <a href="Cardano-Prelude-GHC-Heap-Size.html#t:CountFailure" title="Cardano.Prelude.GHC.Heap.Size">CountFailure</a> &#8594; <a href="file:///opt/ghc/8.10.2/share/doc/ghc-8.10.2/html/libraries/base-4.14.1.0/Data-String.html#t:String" title="Data.String">String</a> <a href="#v:show" class="selflink">#</a></p><p class="src"><a href="#v:showList">showList</a> &#8759; [<a href="Cardano-Prelude-GHC-Heap-Size.html#t:CountFailure" title="Cardano.Prelude.GHC.Heap.Size">CountFailure</a>] &#8594; <a href="file:///opt/ghc/8.10.2/share/doc/ghc-8.10.2/html/libraries/base-4.14.1.0/Text-Show.html#t:ShowS" title="Text.Show">ShowS</a> <a href="#v:showList" class="selflink">#</a></p></div></details></td></tr></table></details></div></div><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:PerformGC" class="def">PerformGC</a> <a href="src/Cardano.Prelude.GHC.Heap.Size.html#PerformGC" class="link">Source</a> <a href="#t:PerformGC" class="selflink">#</a></p><div class="doc"><p>Should we perform a GC call before counting the size?</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a id="v:FirstPerformGC" class="def">FirstPerformGC</a></td><td class="doc"><p>Yes, first perform GC before counting</p><p>This should be used for most accurate results. Without calling GC first,
 the computed size might be larger than expected due to leftover
 indirections (black holes, selector thunks, etc.)</p></td></tr><tr><td class="src"><a id="v:DontPerformGC" class="def">DontPerformGC</a></td><td class="doc"><p>No, do not perform GC before counting</p><p>If pinpoint accuracy is not requried, then GC can be skipped, making the
 call much less expensive.</p></td></tr></table></div></div><div class="top"><p class="src"><a id="v:computeHeapSize" class="def">computeHeapSize</a> &#8759; a &#8594; <a href="Cardano-Prelude-Base.html#t:IO" title="Cardano.Prelude.Base">IO</a> (<a href="Cardano-Prelude-Base.html#t:Either" title="Cardano.Prelude.Base">Either</a> <a href="Cardano-Prelude-GHC-Heap-Size.html#t:CountFailure" title="Cardano.Prelude.GHC.Heap.Size">CountFailure</a> <a href="Cardano-Prelude-Base.html#t:Word64" title="Cardano.Prelude.Base">Word64</a>) <a href="src/Cardano.Prelude.GHC.Heap.Size.html#computeHeapSize" class="link">Source</a> <a href="#v:computeHeapSize" class="selflink">#</a></p><div class="doc"><p>Compute the size of the given closure</p><p>This is a wrapper around <code><a href="Cardano-Prelude-GHC-Heap-Size.html#v:computeHeapSize-39-" title="Cardano.Prelude.GHC.Heap.Size">computeHeapSize'</a></code> which sets some defaults for the
 capacity of worklist and the visited set: it uses a worklist capacity of 10k
 (which, assuming balanced data structures, should be more than enough), an
 initial visited set capacity of 250k, and a maximum visited set capacity of
 16M. This means that this will use between 2 MB and 128 MB of heaps space.</p><p>It also does NOT perform GC before counting, for improved performance.
 Client code can call <code><a href="file:///opt/ghc/8.10.2/share/doc/ghc-8.10.2/html/libraries/base-4.14.1.0/System-Mem.html#v:performMajorGC" title="System.Mem">performMajorGC</a></code> manually or use <code><a href="Cardano-Prelude-GHC-Heap-Size.html#v:computeHeapSize-39-" title="Cardano.Prelude.GHC.Heap.Size">computeHeapSize'</a></code>.</p><p>Should these limits not be sufficient, or conversely, the memory requirements
 be too large, use <code><a href="Cardano-Prelude-GHC-Heap-Size.html#v:computeHeapSize-39-" title="Cardano.Prelude.GHC.Heap.Size">computeHeapSize'</a></code> directly.</p></div></div><div class="top"><p class="src"><a id="v:computeHeapSize-39-" class="def">computeHeapSize'</a> <a href="src/Cardano.Prelude.GHC.Heap.Size.html#computeHeapSize%27" class="link">Source</a> <a href="#v:computeHeapSize-39-" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">&#8759; <a href="Cardano-Prelude-GHC-Heap-Size.html#t:PerformGC" title="Cardano.Prelude.GHC.Heap.Size">PerformGC</a></td><td class="doc"><p>Should we call GC before counting?</p></td></tr><tr><td class="src">&#8594; <a href="Cardano-Prelude-Base.html#t:Word" title="Cardano.Prelude.Base">Word</a></td><td class="doc"><p>Capacity of the worklist</p></td></tr><tr><td class="src">&#8594; <a href="Cardano-Prelude-Base.html#t:Word" title="Cardano.Prelude.Base">Word</a></td><td class="doc"><p>Initial capacity of the visited set</p></td></tr><tr><td class="src">&#8594; <a href="Cardano-Prelude-Base.html#t:Word" title="Cardano.Prelude.Base">Word</a></td><td class="doc"><p>Maximum capacity of the visited set</p></td></tr><tr><td class="src">&#8594; a</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">&#8594; <a href="Cardano-Prelude-Base.html#t:IO" title="Cardano.Prelude.Base">IO</a> (<a href="Cardano-Prelude-Base.html#t:Either" title="Cardano.Prelude.Base">Either</a> <a href="Cardano-Prelude-GHC-Heap-Size.html#t:CountFailure" title="Cardano.Prelude.GHC.Heap.Size">CountFailure</a> <a href="Cardano-Prelude-Base.html#t:Word64" title="Cardano.Prelude.Base">Word64</a>)</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Compute the size of the given closure</p><p>The size of the worklist should be set to the maximum expected <em>depth</em> of
 the closure; the size of the visited set should be set to the maximum /number
 of nodes/ in the closure.</p><p><code><a href="Cardano-Prelude-GHC-Heap-Size.html#v:computeHeapSizeWorkList" title="Cardano.Prelude.GHC.Heap.Size">computeHeapSizeWorkList</a></code> can be used to estimate the size of the worklist
 required.</p></div></div><div class="top"><p class="src"><a id="v:computeHeapSizeWorkList" class="def">computeHeapSizeWorkList</a> &#8759; a &#8594; <a href="Cardano-Prelude-Base.html#t:Word64" title="Cardano.Prelude.Base">Word64</a> <a href="src/Cardano.Prelude.GHC.Heap.Size.html#computeHeapSizeWorkList" class="link">Source</a> <a href="#v:computeHeapSizeWorkList" class="selflink">#</a></p><div class="doc"><p>Upper bound on the required work list size to compute closure size</p><p>NOTE: This ignores sharing, and so provides an upper bound only.</p><p>The size of a closure with no nested pointers can be computed without any
 stack space.</p><p>When we have a closure with <code>(N + 1)</code> nested pointers</p><pre>p0 p1 .. pN</pre><p>We will</p><ul><li>Push <code>pN, .., p1, p0</code> onto the stack</li><li>Pop off <code>p0</code> and count its children</li><li>Pop off <code>p1</code> and count its children</li><li>..</li></ul><p>until we have processed all children. This means that the stack space
 required will be the maximum of</p><pre>[ N + 1 -- For the initial list
, requiredWorkList p0 + (N + 1) - 1
, requiredWorkList p1 + (N + 1) - 2
, ..
, requiredWorkList pN + (N + 1) - (N + 1)
]</pre><p>For example, for a list, we would get that</p><pre>requiredWorkList []     == 0
requiredWorkList (x:xs) == max [ 2
                               , requiredWorkList x + 1
                               , requiredWorkList xs
                               ]</pre><p>which, for a list of <code>Int</code> (which requires only a stack of size 1), equals 2
 (unless the list is empty).</p><p>Similarly, for binary trees, we get</p><pre>requiredWorkList Leaf           == 0
requiredWorkList (Branch l x r) == max [ 3
                                       , requiredWorkList l + 2
                                       , requiredWorkList x + 1
                                       , requiredWorkList r
                                       ]</pre><p>which, for a tree of <code>Int</code>, is bound by <code>(height * 2) + 1</code>.</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.24.0</p></div></body></html>